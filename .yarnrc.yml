import asyncio
import logging
from typing import Dict, Any

from aster.lib.utils import config_logging
from aster.websocket.client.stream import WebsocketClient as Client

# Set up logging for the client application
config_logging(logging, logging.DEBUG)
logger = logging.getLogger(__name__)

# --- Handlers ---

def message_handler(message: Dict[str, Any]) -> None:
    """
    Handles incoming messages from the WebSocket stream.
    
    Args:
        message: The parsed message payload (usually JSON).
    """
    logger.info(f"Received message: {message}")

# --- Main Application Logic ---

async def main_async(duration: int = 60):
    """
    Asynchronously runs the WebSocket client, subscribes to a stream, 
    and keeps the connection alive for a set duration.

    Args:
        duration: The time in seconds to keep the stream active. Use 0 for indefinite running.
    """
    client = Client()
    
    try:
        logger.debug("Starting WebSocket client...")
        # Start the client (likely runs in a separate thread/task internally)
        client.start()

        # Subscribe to a stream
        logger.info("Subscribing to mini_ticker stream for BTCUSDT...")
        client.mini_ticker(
            id=1,
            callback=message_handler,
            symbol="btcusdt"
        )

        # Keep the main coroutine alive to allow the client thread/task to run
        if duration > 0:
            logger.info(f"Waiting for {duration} seconds of streaming data...")
            await asyncio.sleep(duration)
        else:
            logger.info("Running indefinitely. Press Ctrl+C to stop.")
            # Use an infinite loop to keep the asyncio event loop running
            while True:
                await asyncio.sleep(3600)  # Sleep for an hour and repeat

        
    except Exception as e:
        logger.error(f"An error occurred during client execution: {e}", exc_info=True)
        
    finally:
        # Ensure the client connection is closed cleanly, regardless of errors
        logger.debug("Closing WebSocket connection.")
        client.stop()
        logger.info("Client stopped successfully.")

if __name__ == "__main__":
    # You can change the duration here (e.g., 300 seconds for 5 minutes, or 0 for indefinite run)
    STREAM_DURATION = 30 
    
    try:
        asyncio.run(main_async(duration=STREAM_DURATION))
    except KeyboardInterrupt:
        logger.warning("Program interrupted by user. Stopping client...")
    except RuntimeError as e:
        # Handle the common RuntimeError when asyncio tries to close the loop
        if "Event loop is closed" not in str(e):
             raise
